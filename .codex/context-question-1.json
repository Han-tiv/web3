{
  "question": "如何在批量抓取过程中实现稳健的速率控制与重试，以避免 Nitter 实例被封锁或频繁超时？",
  "analysis_timestamp": "2025-10-20T14:18:53Z",
  "evidence": [
    {
      "path": "apps/social-monitor/services/nitter/src/userService.ts:20",
      "snippet": "private nitterInstances: string[] = [\n    process.env.NITTER_URL || 'http://localhost:8080',\n    'https://nitter.net',\n    'https://nitter.it',\n    'https://nitter.unixfox.eu',\n    'https://nitter.domain.glass'\n  ];",
      "insight": "服务维护一个 Nitter 实例列表，按顺序尝试，缺少速率与失败退避策略。"
    },
    {
      "path": "apps/social-monitor/services/nitter/src/userService.ts:28",
      "snippet": "private async tryNitterInstance(instance: string, endpoint: string): Promise<any> {\n    try {\n      const response = await axios.get(`${instance}${endpoint}`, {\n        timeout: 10000,\n        headers: {\n          'User-Agent': 'Mozilla/5.0 ...'\n        }\n      });\n      return response;\n    } catch (error) {\n      console.log(`Failed to connect to ${instance}: ${error}`);\n      throw error;\n    }\n  }",
      "insight": "请求失败时仅打印并抛出，未加入重试限速逻辑。"
    },
    {
      "path": "apps/social-monitor/services/nitter/src/index.ts:147",
      "snippet": "        // Rate limiting - wait 1 second between accounts\n        await new Promise(resolve => setTimeout(resolve, 1000));",
      "insight": "实时监控场景使用 1 秒延迟，但批处理面对数百账号时可能仍然过快。"
    }
  ],
  "preliminary_conclusion": "现有实现仅依靠顺序尝试不同实例，缺少统一的节流与退避策略。批量归档需要引入全局限速（如 account 间 sleep、实例切换延迟）以及失败重试次数/指数退避。",
  "follow_up_actions": [
    "设计 configurable 的延迟（如默认 3 秒）并支持随机抖动，减少集中请求。",
    "实现按账号重试至多个实例失败后记录失败列表，以便后续手动重跑。",
    "考虑加入并发控制（一次仅抓取 N 个账号），避免同时打爆实例。"
  ]
}
