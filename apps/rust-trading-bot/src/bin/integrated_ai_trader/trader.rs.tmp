//! IntegratedAITrader - æ ¸å¿ƒçŠ¶æ€ç®¡ç†
//!
//! åŒ…å«äº¤æ˜“å™¨çš„æ ¸å¿ƒçŠ¶æ€ã€é…ç½®å’ŒåŸºç¡€æ–¹æ³•

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use log::{info, warn};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::Arc;
use std::time::Instant;
use tokio::sync::{Mutex, RwLock};

use rust_trading_bot::{
    binance_client::BinanceClient,
    database::Database,
    deepseek_client::{DeepSeekClient, Kline, TechnicalIndicators},
    entry_zone_analyzer::EntryZoneAnalyzer,
    exchange_trait::ExchangeClient,
    gemini_client::GeminiClient,
    key_level_finder::KeyLevelFinder,
    launch_signal_detector::LaunchSignalDetector,
    signals::{FundAlert, SignalContext},
    staged_position_manager::StagedPositionManager,
    technical_analysis::TechnicalAnalyzer,
    trading::OrderManager,
};

use super::utils;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// é…ç½®å¸¸é‡
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

/// æŒä»“æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰- å·²ä¼˜åŒ–ä¸º3åˆ†é’Ÿ
pub const POSITION_CHECK_INTERVAL_SECS: u64 = 180;

/// æ³¢åŠ¨ç‡ç¼“å­˜TTLï¼ˆç§’ï¼‰
#[allow(dead_code)]
pub const VOLATILITY_CACHE_TTL_SECS: u64 = 60;

/// æ³¢åŠ¨ç‡è®¡ç®—è¶…æ—¶ï¼ˆç§’ï¼‰
#[allow(dead_code)]
pub const VOLATILITY_TIMEOUT_SECS: u64 = 5;

/// æ³¢åŠ¨ç‡å›çœ‹çª—å£
#[allow(dead_code)]
pub const VOLATILITY_LOOKBACK: usize = 20;

/// é»˜è®¤æ³¢åŠ¨ç‡ç™¾åˆ†æ¯”
#[allow(dead_code)]
pub const DEFAULT_VOLATILITY_PERCENT: f64 = 2.0;

/// æ˜¯å¦ä½¿ç”¨å¢å¼ºç‰ˆåˆ†æ
#[allow(dead_code)]
pub const USE_ENHANCED_ANALYSIS: bool = false;

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// æ•°æ®ç»“æ„å®šä¹‰
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

/// å»¶è¿Ÿå¼€ä»“é˜Ÿåˆ—è®°å½• - é¦–æ¬¡æœªå¼€ä»“çš„å¸ç§,ç­‰å¾…æ›´å¥½æ—¶æœº
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PendingEntry {
    pub symbol: String,
    pub first_signal_time: DateTime<Utc>,
    pub last_analysis_time: DateTime<Utc>,
    pub alert: FundAlert,
    pub reject_reason: String, // ä¸ºä»€ä¹ˆé¦–æ¬¡è¢«æ‹’ç»: "ä»·æ ¼ä¸ç¬¦"/"AI SKIP"/"ç­‰å¾…å›è°ƒ"
    pub retry_count: u32,      // å·²é‡è¯•æ¬¡æ•°
}

/// æŒä»“è¿½è¸ªä¿¡æ¯
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PositionTracker {
    pub symbol: String,
    pub entry_price: f64,
    pub quantity: f64,
    pub leverage: u32,
    pub side: String,
    pub stop_loss_order_id: Option<String>,
    pub take_profit_order_id: Option<String>,
    pub entry_time: DateTime<Utc>,
    pub last_check_time: DateTime<Utc>,
}

/// æŒä»“è¿½è¸ªå™¨å¿«ç…§ - ç”¨äºæ— é”è¯»å–
#[derive(Debug, Clone)]
pub struct TrackerSnapshot {
    pub symbol: String,
    pub side: String,
    pub quantity: f64,
    pub entry_price: f64,
    pub entry_time: DateTime<Utc>,
    pub leverage: u32,
    pub stop_loss_order_id: Option<String>,
    pub take_profit_order_id: Option<String>,
}

/// ç¼“å­˜æ‰¹é‡AIè¯„ä¼°æ‰€éœ€çš„è¡Œæƒ…ä¸Šä¸‹æ–‡ï¼Œé¿å…é‡å¤è·å–Kçº¿
pub struct PositionMarketContext {
    pub klines_5m: Vec<Kline>,
    pub klines_15m: Vec<Kline>,
    pub klines_1h: Vec<Kline>,
    pub indicators: TechnicalIndicators,
}

/// ä¿å­˜æ‰¹é‡AIè¯„ä¼°å®Œæˆåæ‰§è¡Œäº¤æ˜“åŠ¨ä½œæ‰€éœ€çš„æŒä»“ä¿¡æ¯
pub struct BatchActionContext {
    pub side: String,
    pub entry_price: f64,
    pub quantity: f64,
    pub stop_loss_order_id: Option<String>,
    pub take_profit_order_id: Option<String>,
}

/// æ³¢åŠ¨ç‡ç¼“å­˜æ¡ç›®
#[derive(Clone, Copy)]
#[allow(dead_code)]
pub struct VolatilityCacheEntry {
    pub value: f64,
    pub cached_at: Instant,
}

/// è§¦å‘å•è·Ÿè¸ªè®°å½•
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct TriggerOrderRecord {
    pub order_id: String,
    pub symbol: String,
    pub position_side: String,
    pub trigger_price: f64,
    pub action: String, // "OPEN" or "CLOSE"
    pub created_at: DateTime<Utc>,
    pub reason: String,
}

/// æŒä»“ç›‘æ§é˜¶æ®µéœ€è¦æ‰§è¡Œçš„åŠ¨ä½œï¼Œé‡‡ç”¨"å…ˆæ”¶é›†å†å¤„ç†"ç­–ç•¥é¿å…é”é‡å…¥
#[derive(Debug)]
pub enum PositionAction {
    FullClose {
        symbol: String,
        side: String,
        quantity: f64,
        reason: String,
    },
    PartialClose {
        symbol: String,
        side: String,
        close_quantity: f64,
        close_pct: f64,
        entry_price: f64,
        stop_loss_price: f64, // âœ… Bug Fix: ä¿å­˜åŸå§‹æ­¢æŸä»·æ ¼,éƒ¨åˆ†å¹³ä»“åé‡è®¾æ­¢æŸå•ä½¿ç”¨
        remaining_quantity: f64,
        stop_loss_order_id: Option<String>,
    },
    Remove(String),
    SetLimitOrder {
        symbol: String,
        side: String,
        quantity: f64,
        limit_price: f64,
        take_profit_order_id: Option<String>,
    },
}

/// å¯¹è¿½è¸ªå™¨çš„æ›´æ–°æ“ä½œï¼Œç»Ÿä¸€åœ¨çŸ­æš‚å†™é”ä¸­è½ç›˜
#[derive(Debug)]
pub enum TrackerMutation {
    QuantityAndStopLoss {
        symbol: String,
        new_quantity: f64,
        new_stop_loss_order_id: Option<String>,
    },
    TakeProfitOrder {
        symbol: String,
        new_take_profit_order_id: Option<String>,
    },
}

/// äº¤æ˜“ä¿¡å·è®°å½•
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignalRecord {
    pub timestamp: String,
    pub signal: String,
    pub confidence: String,
    pub reason: String,
    pub price: f64,
}

/// äº¤æ˜“ä¿¡å·å†å²
pub struct SignalHistory {
    signals: VecDeque<SignalRecord>,
    max_size: usize,
}

impl SignalHistory {
    pub fn new(max_size: usize) -> Self {
        Self {
            signals: VecDeque::with_capacity(max_size),
            max_size,
        }
    }

    pub fn add(&mut self, record: SignalRecord) {
        if self.signals.len() >= self.max_size {
            self.signals.pop_front();
        }
        self.signals.push_back(record);
    }

    #[allow(dead_code)]
    pub fn get_recent(&self, count: usize) -> Vec<&SignalRecord> {
        self.signals.iter().rev().take(count).collect()
    }

    #[allow(dead_code)]
    pub fn count_signal(&self, signal: &str, last_n: usize) -> usize {
        self.signals
            .iter()
            .rev()
            .take(last_n)
            .filter(|s| s.signal == signal)
            .count()
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// æ ¸å¿ƒäº¤æ˜“å™¨ç»“æ„ä½“
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

pub struct IntegratedAITrader {
    // === æ ¸å¿ƒå®¢æˆ·ç«¯ ===
    pub exchange: Arc<BinanceClient>,
    pub deepseek: Arc<DeepSeekClient>,
    pub gemini: Arc<GeminiClient>,
    pub analyzer: Arc<TechnicalAnalyzer>,
    #[allow(dead_code)]
    pub level_finder: Arc<KeyLevelFinder>,

    // === æ–°ç­–ç•¥æ¨¡å— ===
    pub entry_zone_analyzer: Arc<EntryZoneAnalyzer>,
    pub launch_detector: Arc<LaunchSignalDetector>,
    pub staged_manager: Arc<RwLock<StagedPositionManager>>,

    // === Alpha/FOMOå…³é”®è¯ ===
    #[allow(dead_code)]
    pub alpha_keywords: Vec<String>,
    #[allow(dead_code)]
    pub fomo_keywords: Vec<String>,

    // === äº¤æ˜“é…ç½® - åŠ¨æ€èŒƒå›´ ===
    pub min_position_usdt: f64,
    pub max_position_usdt: f64,
    pub min_leverage: u32,
    pub max_leverage: u32,

    // === å†…å­˜ç®¡ç†é…ç½® ===
    pub max_tracked_coins: usize,
    pub coin_ttl_hours: i64,

    // === çŠ¶æ€è·Ÿè¸ª ===
    pub tracked_coins: Arc<RwLock<HashMap<String, FundAlert>>>,
    pub position_trackers: Arc<RwLock<HashMap<String, PositionTracker>>>,
    pub signal_history: Arc<RwLock<SignalHistory>>,
    pub last_analysis_time: Arc<RwLock<HashMap<String, DateTime<Utc>>>>,
    #[allow(dead_code)]
    pub volatility_cache: Arc<RwLock<HashMap<String, VolatilityCacheEntry>>>,
    pub active_trigger_orders: Arc<Mutex<Vec<TriggerOrderRecord>>>,
    pub pending_entries: Arc<RwLock<HashMap<String, PendingEntry>>>,

    // === æ•°æ®åº“ä¸è®¢å•ç®¡ç† ===
    pub db: Database,
    pub order_manager: OrderManager,
}

impl IntegratedAITrader {
    /// åˆ›å»ºæ–°çš„é›†æˆAIäº¤æ˜“å™¨å®ä¾‹
    pub async fn new(
        exchange: BinanceClient,
        deepseek_api_key: String,
        gemini_api_key: String,
        db: Database,
    ) -> Self {
        let exchange = Arc::new(exchange);
        let deepseek = Arc::new(DeepSeekClient::new(deepseek_api_key));
        let gemini = Arc::new(GeminiClient::new(gemini_api_key));
        let analyzer = Arc::new(TechnicalAnalyzer);
        let level_finder = Arc::new(KeyLevelFinder::new());
        let entry_zone_analyzer = Arc::new(EntryZoneAnalyzer::default());
        let launch_detector = Arc::new(LaunchSignalDetector::default());
        let staged_manager = Arc::new(RwLock::new(StagedPositionManager::default()));

        let order_manager = OrderManager::new(exchange.clone());

        Self {
            exchange: exchange.clone(),
            deepseek,
            gemini,
            analyzer,
            level_finder,
            entry_zone_analyzer,
            launch_detector,
            staged_manager,
            alpha_keywords: vec![
                "alpha".to_string(),
                "æœºä¼š".to_string(),
                "æ½œåŠ›".to_string(),
            ],
            fomo_keywords: vec![
                "fomo".to_string(),
                "çˆ†å‘".to_string(),
                "æš´æ¶¨".to_string(),
            ],
            min_position_usdt: 6.0,
            max_position_usdt: 50.0,
            min_leverage: 10,
            max_leverage: 20,
            max_tracked_coins: 100,
            coin_ttl_hours: 24,
            tracked_coins: Arc::new(RwLock::new(HashMap::new())),
            position_trackers: Arc::new(RwLock::new(HashMap::new())),
            signal_history: Arc::new(RwLock::new(SignalHistory::new(100))),
            last_analysis_time: Arc::new(RwLock::new(HashMap::new())),
            volatility_cache: Arc::new(RwLock::new(HashMap::new())),
            active_trigger_orders: Arc::new(Mutex::new(Vec::new())),
            pending_entries: Arc::new(RwLock::new(HashMap::new())),
            db,
            order_manager,
        }
    }

    /// åŒæ­¥å·²æœ‰æŒä»“åˆ°tracker
    pub async fn sync_existing_positions(&self) -> Result<()> {
        info!("ğŸ”„ åŒæ­¥å·²æœ‰æŒä»“åˆ°å†…å­˜è¿½è¸ªå™¨...");

        let positions = self.exchange.get_positions().await?;
        let mut trackers = self.position_trackers.write().await;

        for pos in positions {
            // Positionç»“æ„ä½“ä½¿ç”¨çš„æ˜¯quantityè€Œä¸æ˜¯position_amt
            if pos.size.abs() < 0.0001 {
                continue;
            }

            let side = if pos.size > 0.0 {
                "LONG"
            } else {
                "SHORT"
            };

            // å¦‚æœå·²æœ‰tracker,è·³è¿‡
            if trackers.contains_key(&pos.symbol) {
                continue;
            }

            info!(
                "  ğŸ“Œ æ¢å¤æŒä»“: {} {} {} @{}",
                pos.symbol, side, pos.size.abs(), pos.entry_price
            );

            trackers.insert(
                pos.symbol.clone(),
                PositionTracker {
                    symbol: pos.symbol.clone(),
                    entry_price: pos.entry_price,
                    quantity: pos.size.abs(),
                    leverage: 10, // é»˜è®¤æ æ†
                    side: side.to_string(),
                    stop_loss_order_id: None,
                    take_profit_order_id: None,
                    entry_time: Utc::now(),
                    last_check_time: Utc::now(),
                },
            );
        }

        info!("âœ… å·²æ¢å¤ {} ä¸ªæŒä»“åˆ°è¿½è¸ªå™¨", trackers.len());
        Ok(())
    }
}

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// SignalContext trait å®ç°
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

#[async_trait]
impl SignalContext for IntegratedAITrader {
    fn exchange(&self) -> Arc<BinanceClient> {
        self.exchange.clone()
    }

    fn db(&self) -> &Database {
        &self.db
    }

    fn tracked_coins(&self) -> Arc<RwLock<HashMap<String, FundAlert>>> {
        self.tracked_coins.clone()
    }

    fn coin_ttl_hours(&self) -> i64 {
        self.coin_ttl_hours
    }

    fn max_tracked_coins(&self) -> usize {

    /// åˆ†æå¹¶äº¤æ˜“ - TODO: å°†åœ¨entry_analyzeræ¨¡å—ä¸­å®Œæ•´å®ç°
    async fn analyze_and_trade(&self, alert: FundAlert) -> Result<()> {
        info!("ğŸ§  æ”¶åˆ°äº¤æ˜“ä¿¡å·: {} - æš‚æ—¶ä¸å¤„ç†ï¼ˆå¾…å®ç°ï¼‰", alert.coin);
        // TODO: è¿™ä¸ªæ–¹æ³•å°†åœ¨Phase 2ï¼ˆentry_analyzeræ¨¡å—ï¼‰ä¸­å®Œæ•´å®ç°
        // ç°åœ¨åªæ˜¯å ä½ï¼Œè®©ä»£ç èƒ½å¤Ÿç¼–è¯‘
        Ok(())
    }
        self.max_tracked_coins
    }
}
