"""
静态规则漏洞检测器

基于 src/rules/vulnerability_rules.py 中定义的规则引擎,对解析后的合约函数
进行关键字匹配、上下文分析和资金影响评估,输出结构化的漏洞发现结果。
"""

from __future__ import annotations

import re
from typing import Any, Dict, List

from ..rules.vulnerability_rules import FundImpact, VulnerabilityRuleEngine


class VulnerabilityDetector:
    """漏洞检测器"""

    def __init__(self) -> None:
        self.rule_engine = VulnerabilityRuleEngine()

    # ------------------------------------------------------------------ #
    # 对外接口
    # ------------------------------------------------------------------ #
    def detect(self, contract: Dict[str, Any]) -> List[Dict[str, Any]]:
        """检测单个合约中的漏洞

        参数:
            contract: 解析后的合约字典,需包含:
                - name: 合约名
                - functions: 函数列表,每个函数包含 name/body/parameters/modifiers/line 等字段
        返回:
            漏洞发现列表
        """
        findings: List[Dict[str, Any]] = []

        for func in contract.get("functions", []):
            context = self._build_context(func, contract)
            matched_rules = self.rule_engine.match_rules(context)

            for rule in matched_rules:
                # 分析资金影响
                fund_impact = self.rule_engine.analyze_fund_impact(
                    func.get("body", "") or "",
                    func.get("name", "") or "",
                )

                # 基于资金影响与配置映射调整严重性
                impact_severity = self.rule_engine.map_fund_impact_to_severity(
                    fund_impact
                )
                final_severity = self._combine_severity(
                    rule.severity, impact_severity
                )

                finding = {
                    "category": rule.category.value,
                    "name": rule.name,
                    "description": rule.description,
                    "severity": final_severity,
                    "fund_impact": fund_impact.value,
                    "contract": contract.get("name"),
                    "function": func.get("name"),
                    "line": func.get("line", 0),
                    "recommendation": rule.recommendation,
                    "reference": rule.reference,
                    "confidence": self._calculate_confidence(
                        rule, context, fund_impact
                    ),
                }

                findings.append(finding)

        return findings

    # ------------------------------------------------------------------ #
    # 内部辅助
    # ------------------------------------------------------------------ #
    def _build_context(
        self, func: Dict[str, Any], contract: Dict[str, Any]
    ) -> Dict[str, Any]:
        """构建检测上下文"""
        body = func.get("body", "") or ""
        # 将函数名拼接到代码前, 便于基于名称的规则匹配(例如 initialize/init/swap 等)
        func_name = func.get("name", "") or ""
        code = f"{func_name} {body}"

        # 简单的赋值/状态变更检测,避免将比较运算误判为状态修改
        assign_pattern = re.compile(r"(?<![=!<>])=(?!=)")
        has_state_change = bool(assign_pattern.search(code)) or "++" in code or "--" in code

        has_external_call = any(
            kw in code
            for kw in [
                "call(",
                ".call{",
                ".transfer(",
                ".send(",
            ]
        )

        has_value_transfer = any(
            kw in code
            for kw in [
                "value:",
                "msg.value",
                ".transfer(",
                ".send(",
                ".call{value",
            ]
        )

        return {
            "code": code,
            "function_name": func_name,
            "params": func.get("parameters", []),
            "modifiers": func.get("modifiers", []),
            "has_external_call": has_external_call,
            "has_state_change": has_state_change,
            "has_value_transfer": has_value_transfer,
            "contract_name": contract.get("name"),
        }

    def _calculate_confidence(
        self,
        rule: Any,
        context: Dict[str, Any],
        fund_impact: FundImpact,
    ) -> float:
        """计算置信度

        综合考虑:
        - 基础置信度
        - 资金影响权重
        - 规则匹配模式数量
        - 上下文要求满足情况
        - 配置中的规则优先级
        """
        base_confidence = 0.6

        # 资金影响加成(使用 YAML 中的权重并做归一化)
        weight = self.rule_engine.get_fund_impact_weight(fund_impact)
        max_weight = max(self.rule_engine.fund_impact_weights.values(), default=10.0)
        impact_bonus = 0.0
        if max_weight > 0:
            impact_bonus = (weight / max_weight) * 0.25

        code_lower = context.get("code", "").lower()
        pattern_matches = sum(
            1 for p in getattr(rule, "patterns", []) if p.lower() in code_lower
        )
        pattern_bonus = min(0.2, pattern_matches * 0.05)

        # 上下文加成: 要求越多且满足越多,置信度越高
        context_bonus = 0.0
        if getattr(rule, "requires_external_call", False) and context.get(
            "has_external_call"
        ):
            context_bonus += 0.07
        if getattr(rule, "requires_state_change", False) and context.get(
            "has_state_change"
        ):
            context_bonus += 0.05
        if getattr(rule, "requires_value_transfer", False) and context.get(
            "has_value_transfer"
        ):
            context_bonus += 0.05

        # 规则优先级加成
        priority = self.rule_engine.get_rule_priority(rule.category)
        priority_bonus = min(0.09, max(0, priority) * 0.03)

        confidence = (
            base_confidence + impact_bonus + pattern_bonus + context_bonus + priority_bonus
        )
        return min(confidence, 0.99)

    @staticmethod
    def _combine_severity(rule_severity: str, impact_severity: str) -> str:
        """将规则严重性与资金影响严重性合并为最终严重性(取更高等级)"""
        sev_rank = {"LOW": 1, "MEDIUM": 2, "HIGH": 3}

        rs = str(rule_severity or "").upper()
        is_ = str(impact_severity or "").upper()

        rs_rank = sev_rank.get(rs, 1)
        is_rank = sev_rank.get(is_, 1)

        final_rank = max(rs_rank, is_rank)
        for name, rank in sev_rank.items():
            if rank == final_rank:
                return name
        return "LOW"
